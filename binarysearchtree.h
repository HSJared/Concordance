/*****************************************************************************																			**	File:		binarysearchtree.h											**																			**	Author:		Robb T. Koether												**																			**	Date:		April 9, 1998												**																			**	Purpose:	This file contains the definition and implementation of 	**				the BinarySearchTree template class							**																			**	Note:		This implementation assumes that the tree does not contain 	**				repeated values.  The insert function as no effect if the	**				value to be inserted is already in the tree.				**																			*****************************************************************************/#ifndef BINARYSEARCHTREE_H#define BINARYSEARCHTREE_H//	Header files#include "binarytree.h"using namespace std;/*****************************************************************************																			**	The BinarySearchTree class definition									**																			*****************************************************************************/template<class T>class BinarySearchTree : public BinaryTree<T>{//	Public member functions	public:		//	Constructors		BinarySearchTree() {}				BinarySearchTree(const T& value) : BinaryTree<T>(value) {}				BinarySearchTree(BinarySearchTree<T>& lf, BinarySearchTree<T>& rt)			: BinaryTree<T>(lf, rt) {}					BinarySearchTree(const T& value, BinarySearchTree<T>& lf, 			BinarySearchTree<T>& rt) : BinaryTree<T>(value, lf, rt) {}					BinarySearchTree(const BinarySearchTree<T>& tree) 			: BinaryTree<T>(tree) {}	//	Mutators			void insert(const T& value);		void remove(const T& value);			//	Other member functions			T* search(const T& value) const;		void countBalance() {countBalance(BinaryTree<T>::root);}		bool isValid() const;	//	Private member functions	private:		bool isValid(const BinaryTreeNode<T>* node) const;		void countBalance(BinaryTreeNode<T>*& node);		void shiftNodesRight(BinaryTreeNode<T>*& node, int count);		void shiftNodesLeft(BinaryTreeNode<T>*& node, int count);};/*****************************************************************************																			**	Function:	Search														**																			**	Purpose:	To search the binary search tree for a given element		**																			*****************************************************************************/template<class T>T* BinarySearchTree<T>::search(const T& value) const{	BinaryTreeNode<T>* node = BinaryTree<T>::root;				// Start at the BinaryTree<T>::root		while (node != NULL && node->data != value)	// Value not found yet		if (value < node->data)					// Value is to the left			node = node->left;					// Move left		else									// Value is to the right			node = node->right;					// Move right				if (node == NULL)							// Value was not found		return NULL;							// Indicate 'not found'	else										// Value was found		return &(node->data);					// Return address of value}/*****************************************************************************																			**	Function:	insert														**																			**	Purpose:	To insert a new element into the binary search tree in		**				its proper place											**																			*****************************************************************************/template<class T>void BinarySearchTree<T>::insert(const T& value){//	Search for place for new node		BinaryTreeNode<T>* prev_node = NULL;		// Trailing pointer	BinaryTreeNode<T>* curr_node = BinaryTree<T>::root;		// Pointer to BinaryTree<T>::root		while (curr_node != NULL)					// Not at leaf yet	{		prev_node = curr_node;					// Preserve pointer			//	cout << "1 \n 1 \n 1 \n 1 \n 1 \n " << endl << "2 \n 2 \n 2 \n 2 \n 2 \n 2 \n 2 \n" << endl;		if (value < curr_node->data)			// Value belongs to left			curr_node = curr_node->left;		// Move left		else if (value > curr_node->data)		// Value belongs to right			curr_node = curr_node->right;		// Move right	}//	Attach the new node to the tree	BinaryTreeNode<T>* new_node = new BinaryTreeNode<T>(value);												// Create new node													if (prev_node == NULL)						// Value belongs at BinaryTree<T>::root		BinaryTree<T>::root = new_node;						// New node is the BinaryTree<T>::root			else if (value <= prev_node->data)			// Value belongs on left		prev_node->left = new_node;				// Attach to left pointer			else										// Value belongs on right		prev_node->right = new_node;			// Attach to right pointer}/*****************************************************************************																			**	Function:	remove														**																			**	Purpose:	To delete an element from a binary search tree				**																			*****************************************************************************/template<class T>void BinarySearchTree<T>::remove(const T& value){//	Find the value to be deleted	BinaryTreeNode<T>* prev_node = NULL;		// Trailing pointer	BinaryTreeNode<T>* curr_node = BinaryTree<T>::root;		// Pointer to the BinaryTree<T>::root		while (curr_node != NULL && curr_node->data != value)	{											// Value not found yet		prev_node = curr_node;					// Preserve pointer		if (value < curr_node->data)			// Value is to the left			curr_node = curr_node->left;		// Move left		else									// Value is to the right			curr_node = curr_node->right;		// Move right	}//	See if the value was found	if (curr_node == NULL)						// Value was not found		return;//	If node has two children, replace it with the next-smaller element	if (curr_node->left != NULL && curr_node->right != NULL)	{											// Node has two children		BinaryTreeNode<T>* old_node = curr_node;// Remember this node			//	Find next-smaller value by moving one step to the left and then 	//	all the way to the right			prev_node = curr_node;					// Remember previous node		curr_node = curr_node->left;			// Move left				while (curr_node->right != NULL)		// There is a right child		{			prev_node = curr_node;				// Remember previous node			curr_node = curr_node->right;		// Move right		}				old_node->data = curr_node->data;		// Copy data to old node	}//	Now the delete node has at most one child	BinaryTreeNode<T>* next_node;				// Needed to delete node		if (curr_node->left == NULL)				// No left child		next_node = curr_node->right;			// Point to right child	else										// No right child		next_node = curr_node->left;			// Point to left child			if (curr_node == BinaryTree<T>::root)						// Search stayed at BinaryTree<T>::root		BinaryTree<T>::root = next_node;						// Reassign BinaryTree<T>::root	else if (curr_node == prev_node->left)		// Node is left child		prev_node->left = next_node;			// Attach to left side	else										// Node is right child		prev_node->right = next_node;			// Attach to right side			delete curr_node;							// Delete the node	return;}/*****************************************************************************																			**	Function:	isValid														**																			**	Purpose:	To verify that the BinarySearchTree has a valid structure	**																			*****************************************************************************/template <class T>bool BinarySearchTree<T>::isValid() const{//	Verify the tree structure//	if (!BinaryTree<T>::isValid())//		return false;	//	Verify the order of the elements	return isValid(BinaryTree<T>::root);}/*****************************************************************************																			**	Function:	isValid(BinaryTreeNode<T>*)									**																			**	Purpose:	To verify that the BinarySearchTree has a valid structure	**																			*****************************************************************************/template <class T>bool BinarySearchTree<T>::isValid(const BinaryTreeNode<T>* node) const{	if (node != NULL)	{		if (node->left != NULL)		{			if (node->left->data > node->data)			{				cout << "Value in left subtree is greater than BinaryTree<T>::root value" << endl;				return false;			}			if (!isValid(node->left))				return false;		}				if (node->right != NULL)		{			if (node->right->data < node->data)			{						}			if (!isValid(node->right))				return false;		}	}	return true;}/*****************************************************************************																			**	Function:	countBalance												**																			**	Purpose:	To modify recursively a binary search tree to make it		**				count-balanced												**																			*****************************************************************************/template <class T>void BinarySearchTree<T>::countBalance(BinaryTreeNode<T>*& node){	if (node != NULL)	{	//	Shift nodes to balance at the BinaryTree<T>::root			int leftSize = this->size(node->left);		int rightSize = this->size(node->right);				if (leftSize > rightSize + 1)			shiftNodesRight(node, (leftSize - rightSize)/2);		else if (rightSize > leftSize + 1)			shiftNodesLeft(node, (rightSize - leftSize)/2);		//	Balance the left and right subtrees		countBalance(node->left);		countBalance(node->right);	}}/*****************************************************************************																			**	Function:	shiftNodesRight												**																			**	Purpose:	To shift the specified number of nodes from the left 		**				subtree to the right subtree								**																			*****************************************************************************/template <class T>void BinarySearchTree<T>::shiftNodesRight(BinaryTreeNode<T>*& root_node, int count){//	Initialize pointers	BinaryTreeNode<T>* prev_node;	BinaryTreeNode<T>* curr_node;	BinaryTreeNode<T>* min_node = root_node->right;//	Locate minimum node in right subtree	if (min_node != NULL)		while (min_node->left != NULL)			min_node = min_node->left;//	Move the specified number of nodes from left to right	for (int i = 0; i < count; i++)	{	//	Locate maximum node in left subtree		assert(root_node->left != NULL);		prev_node = root_node;		curr_node = root_node->left;				while (curr_node->right != NULL)		{			prev_node = curr_node;			curr_node = curr_node->right;		}			//	Rearrange the pointers 		if (min_node == NULL)			curr_node->right = root_node;		else		{			curr_node->right = root_node->right;			min_node->left = root_node;		}				if (prev_node != root_node)		{			prev_node->right = curr_node->left;			curr_node->left = root_node->left;		}				root_node->left = NULL;		root_node->right = NULL;		min_node = root_node;				// Update min_node for next shift		root_node = curr_node;	}			return;}/*****************************************************************************																			**	Function:	shiftNodesLeft												**																			**	Purpose:	To shift the specified number of nodes from the right 		**				subtree to the left subtree									**																			*****************************************************************************/template <class T>void BinarySearchTree<T>::shiftNodesLeft(BinaryTreeNode<T>*& root_node, int count){//	Initialize pointers	BinaryTreeNode<T>* prev_node;	BinaryTreeNode<T>* curr_node;	BinaryTreeNode<T>* max_node = root_node->left;//	Locate minimum node in left subtree	if (max_node != NULL)		while (max_node->right != NULL)			max_node = max_node->right;//	Move the specified number of nodes from right to left	for (int i = 0; i < count; i++)	{	//	Locate minimum node in right subtree		assert(root_node->right != NULL);		prev_node = root_node;		curr_node = root_node->right;				while (curr_node->left != NULL) 		{			prev_node = curr_node;			curr_node = curr_node->left;		}	//	Rearrange the pointers 		if (max_node == NULL)			curr_node->left = root_node;		else		{			curr_node->left = root_node->left;			max_node->right = root_node;		}				if (prev_node != root_node)		{			prev_node->left = curr_node->right;			curr_node->right = root_node->right;		}				root_node->right = NULL;		root_node->left = NULL;		max_node = root_node;				// Update max_node for next shift		root_node = curr_node;	}			return;}#endif