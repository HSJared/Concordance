/*****************************************************************************																			**	File:		circlinkedlist.h											**																			**	Author:		Robb T. Koether												**																			**	Date:		Jul 3, 2000													**																			**	Abstract:	This file contains the definition of the CircLinkedList		**				template class												**																			*****************************************************************************/#ifndef CIRCLINKEDLIST_H#define CIRCLINKEDLIST_H//	Header files#include <iostream>#include <string>#include <cassert>#include "doublylinkedlistnode.h"using namespace std;/*****************************************************************************																			**	The CircLinkedList class definition										**																			*****************************************************************************/template<class T>class CircLinkedList{//	Public member functions	public:	//	Constructors		CircLinkedList(int sz = 0, const T& value = T());		CircLinkedList(const CircLinkedList<T>& lst)			{list = new DoublyLinkedListNode<T>; MakeCopy(lst);}			//	Destructor			~CircLinkedList() {MakeEmpty(); delete list;}	//	Inspectors		T& GetElement(int pos) const;		int Size() const {return size;}		bool Empty() const {return size == 0;}	//	Mutators		void SetElement(int pos, const T& value) {GetElement(pos) = value;}		void Insert(int pos, const T& value);		void Delete(int pos);		void PushFront(const T& value);		void PushBack(const T& value);		T PopFront();		T PopBack();		void MakeEmpty();	//	Facilitators			void Input(istream& in);		void Output(ostream& out) const;		//	Operators			CircLinkedList<T>& operator=(const CircLinkedList<T>& lst);		T& operator[](int pos) const {return GetElement(pos);}	//	Other functions			void Swap(CircLinkedList<T>& lst);		int Search(const T& value) const;		void Sort();		void Validate() const;	//	Private member functions		private:			void MakeCopy(const CircLinkedList<T>&);//	Data members	protected:			int size;		DoublyLinkedListNode<T>* list;	// Node contains head and tail pointers};template <class T>istream& operator>>(istream& in, CircLinkedList<T>&);template <class T>ostream& operator<<(ostream& out, const CircLinkedList<T>&);/*****************************************************************************																			**	Function:	CircLinkedList(int = 0, T = T())							**																			**	Purpose:	To construct a doubly linked list containing a specified	**				number of nodes containing default values					**																			*****************************************************************************/template<class T>inline CircLinkedList<T>::CircLinkedList(int sz, const T& value){	assert(sz >= 0);	size = sz;	//	Create the dummy node	list = new DoublyLinkedListNode<T>;//	Create the other nodes	DoublyLinkedListNode<T>* node = list;	for (int i = 0; i < size; i++)	{		node->next = new DoublyLinkedListNode<T>(value);		node->next->prev = node;		node = node->next;	}		node->next = list;	list->prev = node;	return;}/*****************************************************************************																			**	Function:	GetElement													**																			**	Purpose:	To return the element in the specified position				**																			*****************************************************************************/template<class T>T& CircLinkedList<T>::GetElement(int pos) const{	assert(pos >= 1 && pos <= size);		DoublyLinkedListNode<T>* node = list;		if (pos <= size/2)					// Chase ptrs forward from head		for (int i = 0; i < pos; i++)			node = node->next;				else								// Chase ptrs backward from tail		for (int i = 0; i < size - pos + 1; i++)			node = node->prev;				return node->data;}/*****************************************************************************																			**	Function:	Insert														**																			**	Purpose:	To insert a new element into the specified position of the	**				list														**																			*****************************************************************************/template<class T>void CircLinkedList<T>::Insert(int pos, const T& value){	assert(pos >= 1 && pos <= size + 1);	//	Create a new node	DoublyLinkedListNode<T>* new_node = new DoublyLinkedListNode<T>(value);//	Locate the new position	DoublyLinkedListNode<T>* node = list;		if (pos <= size/2)		for (int i = 0; i < pos; i++)			node = node->next;				else if (pos <= size)		for (int i = 0; i < size - pos + 1; i++)			node = node->prev;//	Insert the new node	new_node->next = node;	new_node->prev = node->prev;	node->prev->next = new_node;	node->prev = new_node;//	Update the size	size++;	return;}/*****************************************************************************																			**	Function:	Delete														**																			**	Purpose:	To delete from the list the element in the specified		**				position													**																			*****************************************************************************/template<class T>void CircLinkedList<T>::Delete(int pos){	assert(pos >= 1 && pos <= size);//	Locate the node to be deleted	DoublyLinkedListNode<T>* node = list;		if (pos <= size/2)		for (int i = 0; i < pos; i++)			node = node->next;	else		for (int i = 0; i < size - pos + 1; i++)			node = node->prev;			//	Delete the node	node->prev->next = node->next;	node->next->prev = node->prev;	delete node;//	Update the size	size--;	return;}/*****************************************************************************																			**	Function:	PushFront													**																			**	Purpose:	To insert the specified value into the first position in	**				the list													**																			*****************************************************************************/template<class T>void CircLinkedList<T>::PushFront(const T& value){//	Create a new node	DoublyLinkedListNode<T>* new_node = new DoublyLinkedListNode<T>(value);//	Append the new node	new_node->prev = list;	new_node->next = list->next;	list->next->prev = new_node;	list->next = new_node;//	Update the size	size++;	return;}/*****************************************************************************																			**	Function:	PushBack													**																			**	Purpose:	To append the specified element onto the end of the list	**																			*****************************************************************************/template<class T>void CircLinkedList<T>::PushBack(const T& value){//	Create a new node	DoublyLinkedListNode<T>* new_node = new DoublyLinkedListNode<T>(value);//	Append the new node	new_node->next = list;	new_node->prev = list->prev;	list->prev->next = new_node;	list->prev = new_node;//	Update the size	size++;	return;}/*****************************************************************************																			**	Function:	PopFront													**																			**	Purpose:	To remove the first element of the list						**																			*****************************************************************************/template<class T>T CircLinkedList<T>::PopFront(){	assert(size > 0);	T value = list->next->data;	DoublyLinkedListNode<T>* old_node = list->next;	old_node->next->prev = list;	list->next = old_node->next;	delete old_node;	size--;	return value;}/*****************************************************************************																			**	Function:	PopBack														**																			**	Purpose:	To append the specified element onto the end of the list	**																			*****************************************************************************/template<class T>T CircLinkedList<T>::PopBack(){	assert(size > 0);	T value = list->prev->data;	DoublyLinkedListNode<T>* old_node = list->prev;	old_node->prev->next = list;	list->prev = old_node->prev;	delete old_node;	size--;	return value;}/*****************************************************************************																			**	Function:	MakeEmpty													**																			**	Purpose:	To remove all elements from the list, returning the list	**				to the empty state											**																			*****************************************************************************/template<class T>void CircLinkedList<T>::MakeEmpty(){	DoublyLinkedListNode<T>* prev_node = list;	DoublyLinkedListNode<T>* curr_node = list->next;	for (int i = 0; i < size; i++)	{		prev_node = curr_node;		curr_node = curr_node->next;		delete prev_node;	}	size = 0;	list->next = list;	list->prev = list;	return;}/*****************************************************************************																			**	Function:	Input														**																			**	Purpose:	To extract a linked list object from the input stream		**																			*****************************************************************************/template <class T>void CircLinkedList<T>::Input(istream& in){	MakeEmpty();	char c;	T value;		in >> c;					// Read the first character	assert(c == '{');			// First char is not '{'	in >> c;					// Read next character	if (c == '}')				// List is empty		return;					// Nothing else to read			else						// List is not empty	{		in.putback(c);			// Put char back in input stream		while(c != '}')			// Read until '}' is found		{			in >> value;		// Read the element		 	PushBack(value);	// Append the element to the list		 	in >> c;			// Read the comma or close brace		}	}	return;}/*****************************************************************************																			**	Function:	Output														**																			**	Purpose:	To insert a doubly linked list into the output stream		**																			*****************************************************************************/template<class T>void CircLinkedList<T>::Output(ostream& out) const{	out << "{";	if (size > 0)	{		DoublyLinkedListNode<T>* node = list;		for (int i = 0; i < size; i++)		{			node = node->next;			out << node->data << ", ";		}		out << "\b\b";	}	out << "}";	return;}/*****************************************************************************																			**	Function:	operator=													**																			**	Purpose:	To assign one doubly linked list to another doubly linked	**				list.  This is the assignment operator.						**																			*****************************************************************************/template<class T>CircLinkedList<T>& CircLinkedList<T>::operator=(const CircLinkedList<T>& lst){	if (this != &lst)	{		MakeEmpty();		MakeCopy(lst);	}	return *this;}/*****************************************************************************																			**	Function:	Swap														**																			**	Purpose:	To swap two circularly linked lists							**																			*****************************************************************************/template <class T>void CircLinkedList<T>::Swap(CircLinkedList<T>& lst){	int tempSize = size;	size = lst.size;	lst.size = tempSize;		DoublyLinkedListNode<T>* tempList = list;	list = lst.list;	lst.list = tempList;		return;}/*****************************************************************************																			**	Function:	Search(T)													**																			**	Purpose:	This function will search the list for the specified 		**				element and report its location								**																			**	Note:		If the element was not found, the function returns 0		**																			*****************************************************************************/template <class T>int CircLinkedList<T>::Search(const T& value) const{	DoublyLinkedListNode<T>* node = list->next;	int count = 1;	while (node != list && node->data != value)	{		node = node->next;		count++;	}	if (node == list)		return 0;	else		return count; }/*****************************************************************************																			**	Function:	Sort														**																			**	Purpose:	This function will sort the members of the list into 		**				ascending order												**																			*****************************************************************************/template <class T>void CircLinkedList<T>::Sort(){	for (DoublyLinkedListNode<T>* base = list->next; base != list->prev;		 base = base->next)	{		DoublyLinkedListNode<T>* min = base;		for (DoublyLinkedListNode<T>* curr = min->next; curr != list;			 curr = curr->next)			if (curr->data < min->data)			 	min = curr;				T temp = base->data;		base->data = min->data;		min->data = temp;	}	return;}/*****************************************************************************																			**	Function:	Validate													**																			**	Purpose:	This function will verify that the CircLinkedList has a		**				valid structure												**																			*****************************************************************************/template <class T>void CircLinkedList<T>::Validate() const{	assert(size >= 0);	assert(list != NULL);//	Count the dummy node as node #0		DoublyLinkedListNode<T>* prev_node = list->prev;	// Node[size]	DoublyLinkedListNode<T>* curr_node = list;			// Node[0]	DoublyLinkedListNode<T>* next_node = list->next;	// Node[1]		assert(size == 0 || prev_node != list);	assert(size == 0 || next_node != list);		for (int i = 1; i <= size; i++)	{		assert(next_node != NULL);				prev_node = curr_node;			// Node[i - 1]		curr_node = next_node;			// Node[i]		next_node = next_node->next;	// Node[i + 1]				assert(prev_node->next == next_node->prev);				assert(i == size || next_node != list);		assert(i == 1 || prev_node != list);				assert(i < size || next_node == list);		assert(i > 1 || prev_node == list);	}		prev_node = curr_node;			// Node[size]	curr_node = next_node;			// Node[0]	next_node = next_node->next;	// Node[1]			assert(prev_node->next == list);		assert(curr_node == list);	assert(next_node->prev == list);		return;}/*****************************************************************************																			**	Function:	MakeCopy													**																			**	Purpose:	To make a copy of the nodes of a list						**																			*****************************************************************************/template <class T>void CircLinkedList<T>::MakeCopy(const CircLinkedList<T>& lst){	size = lst.size;	//	Chase pointers, copying nodes along the way	DoublyLinkedListNode<T>* new_node = list;	DoublyLinkedListNode<T>* old_node = lst.list;		for (int i = 0; i < size; i++)	{		new_node->next = new DoublyLinkedListNode<T>(old_node->next->data);		new_node->next->prev = new_node;		new_node = new_node->next;		old_node = old_node->next;	}//	set tail to last node	new_node->next = list;	list->prev = new_node;	return;}/*****************************************************************************																			**	Function:	operator>>													**																			**	Purpose:	To extract a doubly linked list from the input stream		**																			*****************************************************************************/template<class T>istream& operator>>(istream& in, CircLinkedList<T>& lst){	lst.Input(in);	return in;}/*****************************************************************************																			**	Function:	operator<<													**																			**	Purpose:	To insert a doubly linked list into the output stream		**																			*****************************************************************************/template<class T>ostream& operator<<(ostream& out, const CircLinkedList<T>& lst){	lst.Output(out);	return out;}#endif